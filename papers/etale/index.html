<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta property="og:title" content="Presheaf Type Theories"><meta property="og:description" content="Here is shown the preshifification of cartesian closed categories or topoi."><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://sheaf.space"><link rel="stylesheet" href="https://groupoid.space/main.css"><title>ÉTALE</title></head><body class="content"></body></html><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><script>window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
                        TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
                        extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
                        "HTML-CSS": { imageFont: null },
                        AuthorInit: function() {
                            MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                                var TEX = MathJax.InputJax.TeX;
                                TEX.Definitions.Add({
                                    macros: {
                                      llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                                      rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                                      llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                                      rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                                      incmap:        ['Macro', '\\mathclose{\u21AA}'],
                                    }
                                });
                            });
                        },
                        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                                   processEscapes: true }
                    };
</script><article class="main"><div class="om"><section><h1>ÉTALE SPACES</h1></section></div><aside><a href="https://tonpa.guru">Максим Сохацький</a><time>15 JAN 2019</time></aside><div class="om"><section><figure>$$\def\mapright#1{\xrightarrow{{#1}}}
  \def\mapdown#1{\Big\downarrow\rlap{\raise2pt{\scriptstyle{#1}}}}
  \def\mapdiagl#1{\vcenter{\searrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
  \def\mapdiagr#1{\vcenter{\swarrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
$$</figure><p><b>Definition</b> (Homotopy Pullback).
The pullback of the first diagram (which is called cospan)</p><figure>$$
\begin{array}{ccc}
    & & B \\
    & & \mapdown{\mathbf{g}} \\
    A & \mapright{\mathbf{f}} & C \\
\end{array}
$$</figure><figure>$$
\begin{array}{ccc}
    A \times^{h}_{C} B & \mapright{\mathbf{pb_2}} & B \\
    \mapdown{\mathbf{pb_1}} & \mapdiagl{\mathbf{pb_3}} & \mapdown{\mathbf{g}} \\
    A & \mapright{\mathbf{f}} & C \\
\end{array}
$$</figure><figure>$$
    A \times^{h}_{C} B = \Sigma_A\Sigma_B C^I \\
    = \left\{ (x,y,h) : \Sigma_X\Sigma_Y C^I | h(0)=f(x), h(1)=g(y) \right\}
$$</figure><p>is a $X \times^h_C Y$
together with the projection maps $pb_{1,2,3}$ making the second
diagram commute up to homotopy $H(x,y,h,t) = h(t)$.</p><p><b>Definition</b> (Homotopy Pullback Square). A homotopy pullback or cospan
is called a homotopy pullback square if there exists a homotopy
equivalence $\phi : Z \rightarrow A \times_C^h B$ satisfying
$z_1 : Z \rightarrow A = pb_1 \circ \phi$
and $z_2: Z \rightarrow B = pb_2 \circ \phi$. Map $\phi$ is called induced map.</p><figure>$$
    \begin{array}{ccc}
        X \times^{h}_{C} Y & \mapright{\mathbf{pb_2}} & B \\
        \mapdown{\mathbf{pb_1}} & \square_{(Z,z_1,z_2)} & \mapdown{\mathbf{g}} \\
        A & \mapright{\mathbf{f}} & C \\
    \end{array}
$$</figure><p><b>Definition</b> (Infinitesimal Shape Modality). The two maps
$Im∶ U \rightarrow U$ and $\iota_A ∶ A \rightarrow Im(A)$ are called <i>shape modality</i> if
i) $\iota_A$ is an equivalence, the type $A$ is then called coreduced.; ii)
identity types of coreduced types are coreduced; iii) if $B∶Im(A)\rightarrow U$
is a dependent type such that for all $a∶Im(A)$ the type $B(a)$ is coreduced,
then we can define a section of $B$ by induction.</p><p><b>Definition</b> (Étale map). A map $f:A \rightarrow B$ is <i>formally étale</i>
if its naturality square is a pullback:
$$
\begin{array}{ccc}
    A & \mapright{ι_A} & Im(A) \\
    \mapdown{f} & \square & \mapdown{Im(f)} \\
    B & \mapright{ι_B} & Im(B) \\
\end{array}
$$</p><code>isÉtaleMap (A B: U) (f: A -> B): U
  = isPullbackSq A iA B (Im B) x y w f h where
  iA : U = Im A
  iB : U = Im B
  x: iA -> iB = ImApp  A B f
  y:  B -> iB = ImUnit B
  w:  A -> iA = ImUnit A
  c1: A -> iB = o A iA iB x w
  c2: A -> iB = o A B  iB y f
  T2: U = (a:A) -> Path iB (c1 a) (c2 a)
  h: T2 = \(a : A) -> &lt;i&gt; ImNaturality A B f a @ -i</code><br><code>EtaleMap (A B: U): U
  = (f: A -> B)
  * isÉtaleMap A B f</code><p><b>Definition</b> (Infinitesimal Close).
Let $x,y: A$, then we have a type which could be
read x is infinitesimally close to y and is given as:
$$
    x \sim y =_{def} ι_A (x) = ι_B (y).
$$</p><code>isInfinitesimalClose (X: U) (a x': X): U
  = Path (Im X) (ImUnit X a) (ImUnit X x')</code><p><b>Definition</b> (Formal Disk).
Let $A$ be a type and $a:A$. The type $\mathbb{D}_a$
defined below in three equivalent ways is called
the formal disk at a:
i) $\mathbb{D}_a$ is the sum of all point infinitesimal close to a;
$$
  \mathbb{D}_a =_{def} \sum_{x:A} x \sim a
$$
ii) $\mathbb{D}_a$ is a fiber of $ι_A$ at $ι_A(a)$;
iii) $\mathbb{D}_a$ is defined as a pullback square:
$$
\begin{array}{ccc}
    \mathbb{D}_a & \mapright{} & 1 \\
    \mapdown{} & \square & \mapdown{* \mapsto ι_A(a)} \\
    A & \mapright{ι_A} & Im(A) \\
\end{array}
$$</p><code>formalDisc (X: U) (a: X): U
  = (x': X) * isInfinitesimalClose X a x'</code><p><b>Definition</b> (Differential).
If $f: A \rightarrow B$ is a type, there is a dependent function
$$
    df : \prod_{x:A} \mathbb{D}_x \rightarrow \mathbb{D}_{f(x)}
$$
defined as
$$
   df_a =_{def} (x,ε) \mapsto (f(x),η^{−1}(x)•Im(f(ε))•η_f(x))
$$</p><code>differential (X Y: U) (f: X -> Y) (x: X)
  : formalDisc X x -> formalDisc Y (f x)</code><p><b>Definition</b> (Forma Disk Bundle).
Let $A$ be a type. The type $T_\infty(A)$
defined in one of the equivalent ways below
is called the formal disk bundle of $A$:
i) $T_\infty(A)$ is the sum over all formal disks in A:
$$
  T_\infty(A) =_{def} \sum_{x:A}\mathbb{D}_x
$$
ii) $T_\infty(A)$ is defined by pullback square:
$$
\begin{array}{ccc}
    T_\infty(A) & \mapright{} & A \\
    \mapdown{} & \square & \mapdown{ι_A} \\
    A & \mapright{ι_A} & Im(A) \\
\end{array}
$$</p><code>formalDiscBundle (A: U): U
  = (a: A) * formalDisc A a</code><p><b>Definition</b> (Induced map).
For a map $f : A \rightarrow B$ there is an
induced map on the formal disk bundles, given as
$$
    T_\infty(A) =_{def} (a,ε) \mapsto (f(a),df_a(ε))
$$</p><p><b>Definition</b> (Homogeneous structure).
A type $A$ is homogeneous, if there are terms of the following types:
i) $e:A$; ii) $t: \prod_{x:A} A = A$; iii) $p: \prod_{x:A}t_x(e) = x$.</p><code>homogeneous (A: U): U
  = (e: A)
  * (translationsFamily: (x: A) -> Path U A A)
  * ((x: A) -> Path A (transport (translationsFamily x) e) x)</code><br></section></div></article><footer class="footer"><a href="https://tonpa.guru/"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"></a><span class="footer__copy">2019 &copy; <a href="https://etale.space/" style="color:Lavender;">Étale Infinity</a></span><script src="https://groupoid.space/highlight.js"></script></footer>